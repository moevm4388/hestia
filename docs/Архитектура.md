**Автор:** Шелепугин Иван Михайлович  
**Рецензенты:** Арефьев Иван Дмитриевич, Калениченко Светлана Михайловна, Кислица Сергей Андреевич, Шарапов Даниил Романович  
**Дата:** 18 октября 2025

---

Данный документ описывает общие архитектурные решения и принципы.

## Структура проекта

```
./
└─── hestia/
     ├─── app/
     ├─── common/
     │    ├─── exceptions.py
     │    ├─── types.py
     │    └─── utils.py
     ├─── natural.py
     ├─── integer.py
     ├─── rational.py
     ├─── polynomial.py
     └─── main.py
```

| Директория/файл | Описание                        |
| :-------------: | :------------------------------ |
|      `./`       | Корневая директория репозитория |
|    `hestia/`    | Префикс исходного кода          |
|     `app/`      | Логика приложения               |
|    `common/`    | Общие типы, утилиты и прочее    |
|  `natural.py`   | Модуль натуральных чисел        |
|  `integer.py`   | Модуль целых чисел              |
|  `rational.py`  | Модуль рациональных чисел       |
| `polynomial.py` | Модуль многочленов              |
|    `main.py`    | Точка входа приложения          |

Файлы модулей (`natural.py`, `integer.py`, `rational.py`, `polynomial.py`)
должны начинаться с информации о модуле и членах бригады, которые её
разрабатывали.

Пример файла модуля:

```py
"""
Модуль натуральных чисел

Авторы:
- Иванов Иван Иванович <your@email.com>
- Петров Дмитрий Сергеевич
- ...
"""
```

Если указывается почта, то она должна быть в треугольных скобках (`<>`).


## Функции

Каждой функции соответствует идентификатор, указанный в [описании
проекта](https://docs.google.com/document/d/1Dv_6AIhxg_3ezu6VMcEnMpyfRzgym9l8PmE4ULGfjgM).
Например, функции сравнения натуральных чисел соответствует идентификатор
`COM_NN_D`.

В `common/types.py` определено перечисление (enum) `Identifier`, содержащее
идентификаторы всех функций во всех модулях.


## Типы данных

Для каждого модуля должен определяться свой тип данных. Например, в модуле
натуральных чисел определяется класс `NaturalNumber`.

Конструктор типа данных должен принимать параметры, необходимые для хранения
данных. Например, для натуральных чисел, можно принять параметр типа `int`,
проверить на неотрицательности и сохранить его в экземпляре класса.

Кроме того, типы данных должны определять метод класса (`classmethod`)
`from_str()`, который принимает на вход строку и возвращает новый экземпляр
типа данных. При невозможности конвертировать строку в этот тип данных, нужно
вызвать исключение `ValueError`.

Наконец, тип данных должен определять магический метод `__str__`, который
возвращает его строковое представление.

Пример класса для хранения типа данных:

```py
class MyData:
    def __init__(self, value: int) -> None:
        self.value = value

    def __str__(self) -> str:
        return f"{self.value}"

    @classmethod
    def from_str(cls, s: str) -> "DataType":
        return cls(int(s))
```


## Модули

В каждом модуле должен определяться класс, который содержит методы для
обработки типа данных. Например, для модуля натуральных чисел должен
определяться класс `NaturalModule`.

Методы для обработки данных должны иметь осмысленное название на английском
языке, отражающее описание функции. Названия не должны совпадать с
идентификаторами:

-   **Верно:**
    ```py
    def is_zero(self, v: NaturalNumber) -> bool:
        ...
    ```
-   **НЕВЕРНО**
    ```py
    def NZER_N_B(self, v: NaturalNumber) -> bool:
        ...
    ```

Классы конкретных модулей должны наследоваться от абстрактного класса `Module`,
определённого в `common`.

Конструктор типа данных должен принимать на вход модули, от которых он зависит.
Например, `RationalModule` (модуль рациональных чисел) зависит от модулей
`NaturalModule` (модуль натуральных чисел) и `IntegerModule` (модуль целых
чисел), поэтому конструктор модуля рациональных чисел должен принимать на вход
два параметра — `natural_module: NaturalModule` и `integer_module:
IntegerModule` соответственно. Экземпляры модулей-зависимостей, передаваемые в
конструктор, сохраняются в самом модуле. Если та или иная функция зависит от
функции другого модуля, то её следует вызывать, используя сохранённые
экземпляры. Таким образом, выполняется принцип **внедрения зависимостей**
(Dependency Injection).

Каждый модуль определяет метод `call`, который принимает на вход два параметра:

- `identifier: Identifier` — Идентификатор вызываемого метода (см.
  [Функции](#Функции)).
- `args: list[str]` — Аргументы этого метода.

Аргументы, передаваемые как `args`, необходимо

1. Проверить, соответствует ли количество переданных аргументов количеству
   принимаемых. Например, функция с идентификатором `COM_NN_D` принимает два
   аргумента; если было передано 3 — необходимо вызвать исключение TypeError.
2. Конвертировать аргументы из строки в нужный тип данных.

Если данному идентификатору не соответствует ни одна функция, нужно вызвать
исключение `UnknownIdentifierError`, определённое в `common/exceptions.py`.

Наконец, каждый модуль определяет метод `methods`, который возвращает множество
идентификаторов методов, которые он реализует. Например, в случае с модулем
натуральных чисел, этот модуль должен возвращать идентификаторы всех методов
для работы с натуральными числами.

Пример класса модуля:

```py
from common.exceptions import UnknownIdentifierError
from common.types import Identifier
from common.utils import ensure_args


class MyData:
    ...    # реализация типа данных


class MyModule:
    def __init__(self):
        pass    # у этого модуля нет зависимостей.

    def sum_two_nums(self, lhs: MyData, rhs: MyData) -> MyData:
        ...     # реализация этого метода

    def call(self, identifier: Identifier, args: list[str]) -> Any:
        match identifier:
            case Identifier.SUM_TWO_NUMS:
                ensure_args(identifier, args, 2)    # утилита для проверки кол-ва
                                                    # аргументов
                lhs = MyData.from_str(args[0])
                rhs = MyData.from_str(args[1])
                return self.sum_two_nums(lhs, rhs)
            # ... другие идентификаторы

        raise UnknownIdentifierError(identifier)

    def methods(self) -> set[Identifier]:
        return set([
            Identifier.SUM_TWO_NUMS,
            # ... другие идентификаторы, которые реализует данный модуль
        ])
```


## Правила оформление кода

- Используется стандарт форматирования Python-кода PEP-8.
- У всех функий, классов и методов должны быть docstring-комментарии.
  Рекомендуется использовать reStructuredText как формат комментариев (см.
  пример ниже).
- У всех методов должны быть аннотации типов.

Пример docstring-комментария в формате reStructuredText:

```py
def sum_two_nums(self, lhs: MyData, rhs: MyData) -> MyData:
    """
    Складывает два значения.

    :param lhs: первый операнд
    :param rhs: второй операнд
    :returns: сумма операндов
    """

    return MyData(a.value + b.value)
```


## Полезные ссылки

1. [Python модули и пакеты](https://habr.com/ru/articles/718828/)
2. [classmethod() in Python](https://www.geeksforgeeks.org/python/classmethod-in-python/)
3. [What is a Pythonic Way for Dependency Injection?](https://www.geeksforgeeks.org/python/what-is-a-pythonic-way-for-dependency-injection/)
4. [Введение в аннотации типов Python](https://habr.com/ru/companies/lamoda/articles/432656/)
5. [Форматы docstring в Python](https://sky.pro/media/formaty-docstring-v-python/)
